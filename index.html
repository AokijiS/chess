<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu d'√âchecs</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e8ba3 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
}

.container {
    background: rgba(255, 255, 255, 0.98);
    padding: 30px;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    max-width: 700px;
}

h1 {
    text-align: center;
    color: #1e3c72;
    margin-bottom: 25px;
    font-size: 32px;
    font-weight: 700;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
}

.game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    gap: 15px;
}

.player-section {
    flex: 1;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 15px;
    border-radius: 12px;
    color: white;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}

.player-section.active {
    transform: scale(1.05);
    box-shadow: 0 8px 25px rgba(46, 213, 115, 0.5);
    border: 3px solid #2ed573;
}

.player-name {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 8px;
    opacity: 0.9;
}

.timer {
    font-size: 28px;
    font-weight: 700;
    font-family: 'Courier New', monospace;
    background: rgba(0,0,0,0.2);
    padding: 8px 12px;
    border-radius: 8px;
    text-align: center;
}

.timer.warning {
    background: #ff4757;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-bottom: 20px;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 600;
    font-family: 'Poppins', sans-serif;
    transition: all 0.3s ease;
}

#reset {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

#reset:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}

#pause {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
}

#pause:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
}

#chessboard {
    display: grid;
    grid-template-columns: repeat(8, 70px);
    grid-template-rows: repeat(8, 70px);
    border: 5px solid #2c3e50;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    margin: 0 auto;
}

.square {
    width: 70px;
    height: 70px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: 45px;
    transition: all 0.2s;
    position: relative;
    user-select: none;
}

.light {
    background-color: #f0d9b5;
}

.dark {
    background-color: #b58863;
}

.square:hover {
    filter: brightness(0.9);
}

.selected {
    background-color: #7fc97f !important;
    box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
}

.valid-move {
    background-color: #ffd93d !important;
}

.valid-move::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    background: rgba(0,0,0,0.25);
    border-radius: 50%;
}

.valid-move.capture::after {
    width: 60px;
    height: 60px;
    background: transparent;
    border: 4px solid rgba(255,0,0,0.5);
}

.in-check {
    background-color: #ff6b6b !important;
    animation: checkBlink 0.5s infinite;
}

@keyframes checkBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

#message {
    margin-top: 20px;
    text-align: center;
    font-size: 22px;
    font-weight: 700;
    min-height: 35px;
    padding: 10px;
    border-radius: 10px;
}

#message.checkmate {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    animation: slideIn 0.5s ease;
}

#message.check {
    background: #ff6b6b;
    color: white;
    animation: slideIn 0.5s ease;
}

#message.stalemate {
    background: #95a5a6;
    color: white;
    animation: slideIn 0.5s ease;
}

@keyframes slideIn {
    from {
        transform: translateY(-20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

#status {
    text-align: center;
    margin-top: 10px;
    font-size: 15px;
    color: #555;
    min-height: 20px;
}

@media (max-width: 768px) {
    #chessboard {
        grid-template-columns: repeat(8, 45px);
        grid-template-rows: repeat(8, 45px);
    }
    
    .square {
        width: 45px;
        height: 45px;
        font-size: 30px;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Jeu d'√âchecs ‚ôî</h1>
        
        <div class="game-info">
            <div class="player-section" id="player-black">
                <div class="player-name">‚ôö Joueur Noir</div>
                <div class="timer" id="timer-black">10:00</div>
            </div>
            <div class="player-section active" id="player-white">
                <div class="player-name">‚ôî Joueur Blanc</div>
                <div class="timer" id="timer-white">10:00</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="reset" class="btn">üîÑ Nouvelle Partie</button>
            <button id="pause" class="btn">‚è∏ Pause</button>
        </div>
        
        <div id="chessboard"></div>
        <div id="message"></div>
        <div id="status"></div>
    </div>
    <script>
const pieces = {
    white: {
        king: '‚ôî',
        queen: '‚ôï',
        rook: '‚ôñ',
        bishop: '‚ôó',
        knight: '‚ôò',
        pawn: '‚ôô'
    },
    black: {
        king: '‚ôö',
        queen: '‚ôõ',
        rook: '‚ôú',
        bishop: '‚ôù',
        knight: '‚ôû',
        pawn: '‚ôü'
    }
};

let board = [];
let selectedSquare = null;
let currentPlayer = 'white';
let gameOver = false;
let isPaused = false;
let timerWhite = 600;
let timerBlack = 600;
let timerInterval = null;

const initialBoard = [
    ['‚ôú','‚ôû','‚ôù','‚ôõ','‚ôö','‚ôù','‚ôû','‚ôú'],
    ['‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô'],
    ['‚ôñ','‚ôò','‚ôó','‚ôï','‚ôî','‚ôó','‚ôò','‚ôñ']
];

function initGame() {
    board = initialBoard.map(row => [...row]);
    currentPlayer = 'white';
    gameOver = false;
    isPaused = false;
    selectedSquare = null;
    timerWhite = 600;
    timerBlack = 600;
    
    document.getElementById('message').textContent = '';
    document.getElementById('message').className = '';
    document.getElementById('status').textContent = '';
    
    updateTimerDisplay();
    updatePlayerActive();
    renderBoard();
    startTimer();
}

function renderBoard() {
    const chessboard = document.getElementById('chessboard');
    chessboard.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
            square.dataset.row = row;
            square.dataset.col = col;
            square.textContent = board[row][col];
            square.addEventListener('click', () => handleSquareClick(row, col));
            chessboard.appendChild(square);
        }
    }
    
    highlightKingInCheck();
}

function handleSquareClick(row, col) {
    if (gameOver || isPaused) return;
    
    const clickedPiece = board[row][col];
    
    if (selectedSquare) {
        const validMoves = getValidMoves(selectedSquare.row, selectedSquare.col);
        const isValidMove = validMoves.some(move => move.row === row && move.col === col);
        
        if (isValidMove) {
            movePiece(selectedSquare.row, selectedSquare.col, row, col);
            selectedSquare = null;
            clearHighlights();
            
            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            const isInCheck = isKingInCheck(opponentColor);
            
            if (checkForCheckmate(opponentColor)) {
                gameOver = true;
                stopTimer();
                const winner = currentPlayer === 'white' ? 'Blancs' : 'Noirs';
                showMessage(`√âchec et Mat! Les ${winner} gagnent! üëë`, 'checkmate');
                return;
            }
            
            if (checkForStalemate(opponentColor)) {
                gameOver = true;
                stopTimer();
                showMessage('Pat! Match nul!', 'stalemate');
                return;
            }
            
            if (isInCheck) {
                showMessage('√âchec!', 'check');
            } else {
                document.getElementById('message').textContent = '';
                document.getElementById('message').className = '';
            }
            
            currentPlayer = opponentColor;
            updatePlayerActive();
        } else {
            selectedSquare = null;
            clearHighlights();
            
            if (clickedPiece && getPieceColor(clickedPiece) === currentPlayer) {
                selectSquare(row, col);
            }
        }
    } else {
        if (clickedPiece && getPieceColor(clickedPiece) === currentPlayer) {
            selectSquare(row, col);
        }
    }
}

function selectSquare(row, col) {
    selectedSquare = { row, col };
    highlightSquare(row, col);
    highlightValidMoves(row, col);
}

function highlightSquare(row, col) {
    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    square.classList.add('selected');
}

function highlightValidMoves(row, col) {
    const validMoves = getValidMoves(row, col);
    validMoves.forEach(move => {
        const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
        square.classList.add('valid-move');
        if (board[move.row][move.col]) {
            square.classList.add('capture');
        }
    });
}

function clearHighlights() {
    document.querySelectorAll('.square').forEach(square => {
        square.classList.remove('selected', 'valid-move', 'capture');
    });
}

function highlightKingInCheck() {
    const kingPos = findKing(currentPlayer);
    if (kingPos && isKingInCheck(currentPlayer)) {
        const square = document.querySelector(`[data-row="${kingPos.row}"][data-col="${kingPos.col}"]`);
        square.classList.add('in-check');
    }
}

function movePiece(fromRow, fromCol, toRow, toCol) {
    board[toRow][toCol] = board[fromRow][fromCol];
    board[fromRow][fromCol] = '';
    renderBoard();
}

function getPieceColor(piece) {
    const whitePieces = Object.values(pieces.white);
    const blackPieces = Object.values(pieces.black);
    
    if (whitePieces.includes(piece)) return 'white';
    if (blackPieces.includes(piece)) return 'black';
    return null;
}

function getPieceType(piece) {
    for (let color in pieces) {
        for (let type in pieces[color]) {
            if (pieces[color][type] === piece) return type;
        }
    }
    return null;
}

function getValidMoves(row, col) {
    const piece = board[row][col];
    const pieceType = getPieceType(piece);
    const pieceColor = getPieceColor(piece);
    
    if (!pieceType) return [];
    
    let moves = [];
    
    switch(pieceType) {
        case 'pawn':
            moves = getPawnMoves(row, col, pieceColor);
            break;
        case 'rook':
            moves = getRookMoves(row, col, pieceColor);
            break;
        case 'knight':
            moves = getKnightMoves(row, col, pieceColor);
            break;
        case 'bishop':
            moves = getBishopMoves(row, col, pieceColor);
            break;
        case 'queen':
            moves = getQueenMoves(row, col, pieceColor);
            break;
        case 'king':
            moves = getKingMoves(row, col, pieceColor);
            break;
    }
    
    return moves.filter(move => !wouldBeInCheck(row, col, move.row, move.col, pieceColor));
}

function getPawnMoves(row, col, color) {
    const moves = [];
    const direction = color === 'white' ? -1 : 1;
    const startRow = color === 'white' ? 6 : 1;
    
    if (isValidSquare(row + direction, col) && !board[row + direction][col]) {
        moves.push({ row: row + direction, col });
        
        if (row === startRow && !board[row + 2 * direction][col]) {
            moves.push({ row: row + 2 * direction, col });
        }
    }
    
    [[row + direction, col - 1], [row + direction, col + 1]].forEach(([r, c]) => {
        if (isValidSquare(r, c) && board[r][c] && getPieceColor(board[r][c]) !== color) {
            moves.push({ row: r, col: c });
        }
    });
    
    return moves;
}

function getRookMoves(row, col, color) {
    return getSlidingMoves(row, col, color, [[0,1],[0,-1],[1,0],[-1,0]]);
}

function getBishopMoves(row, col, color) {
    return getSlidingMoves(row, col, color, [[1,1],[1,-1],[-1,1],[-1,-1]]);
}

function getQueenMoves(row, col, color) {
    return getSlidingMoves(row, col, color, [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]);
}

function getSlidingMoves(row, col, color, directions) {
    const moves = [];
    
    directions.forEach(([dRow, dCol]) => {
        let r = row + dRow;
        let c = col + dCol;
        
        while (isValidSquare(r, c)) {
            if (!board[r][c]) {
                moves.push({ row: r, col: c });
            } else {
                if (getPieceColor(board[r][c]) !== color) {
                    moves.push({ row: r, col: c });
                }
                break;
            }
            r += dRow;
            c += dCol;
        }
    });
    
    return moves;
}

function getKnightMoves(row, col, color) {
    const moves = [];
    const knightMoves = [
        [-2,-1],[-2,1],[-1,-2],[-1,2],
        [1,-2],[1,2],[2,-1],[2,1]
    ];
    
    knightMoves.forEach(([dRow, dCol]) => {
        const r = row + dRow;
        const c = col + dCol;
        
        if (isValidSquare(r, c) && (!board[r][c] || getPieceColor(board[r][c]) !== color)) {
            moves.push({ row: r, col: c });
        }
    });
    
    return moves;
}

function getKingMoves(row, col, color) {
    const moves = [];
    const kingMoves = [
        [-1,-1],[-1,0],[-1,1],[0,-1],
        [0,1],[1,-1],[1,0],[1,1]
    ];
    
    kingMoves.forEach(([dRow, dCol]) => {
        const r = row + dRow;
        const c = col + dCol;
        
        if (isValidSquare(r, c) && (!board[r][c] || getPieceColor(board[r][c]) !== color)) {
            moves.push({ row: r, col: c });
        }
    });
    
    return moves;
}

function isValidSquare(row, col) {
    return row >= 0 && row < 8 && col >= 0 && col < 8;
}

function findKing(color) {
    const kingPiece = color === 'white' ? pieces.white.king : pieces.black.king;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (board[row][col] === kingPiece) {
                return { row, col };
            }
        }
    }
    return null;
}

function isKingInCheck(color) {
    const kingPos = findKing(color);
    if (!kingPos) return false;
    
    const opponentColor = color === 'white' ? 'black' : 'white';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === opponentColor) {
                const moves = getPieceMoves(row, col, opponentColor);
                if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                    return true;
                }
            }
        }
    }
    
    return false;
}

function getPieceMoves(row, col, color) {
    const pieceType = getPieceType(board[row][col]);
    
    switch(pieceType) {
        case 'pawn': return getPawnMoves(row, col, color);
        case 'rook': return getRookMoves(row, col, color);
        case 'knight': return getKnightMoves(row, col, color);
        case 'bishop': return getBishopMoves(row, col, color);
        case 'queen': return getQueenMoves(row, col, color);
        case 'king': return getKingMoves(row, col, color);
        default: return [];
    }
}

function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
    const originalPiece = board[toRow][toCol];
    const movingPiece = board[fromRow][fromCol];
    
    board[toRow][toCol] = movingPiece;
    board[fromRow][fromCol] = '';
    
    const inCheck = isKingInCheck(color);
    
    board[fromRow][fromCol] = movingPiece;
    board[toRow][toCol] = originalPiece;
    
    return inCheck;
}

function checkForCheckmate(color) {
    if (!isKingInCheck(color)) return false;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === color) {
                const moves = getValidMoves(row, col);
                if (moves.length > 0) {
                    return false;
                }
            }
        }
    }
    
    return true;
}

function checkForStalemate(color) {
    if (isKingInCheck(color)) return false;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === color) {
                const moves = getValidMoves(row, col);
                if (moves.length > 0) {
                    return false;
                }
            }
        }
    }
    
    return true;
}

function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    
    timerInterval = setInterval(() => {
        if (!gameOver && !isPaused) {
            if (currentPlayer === 'white') {
                timerWhite--;
                if (timerWhite <= 0) {
                    gameOver = true;
                    stopTimer();
                    showMessage('Temps √©coul√©! Les Noirs gagnent! ‚è±Ô∏è', 'checkmate');
                    return;
                }
                if (timerWhite <= 30) {
                    document.getElementById('timer-white').classList.add('warning');
                }
            } else {
                timerBlack--;
                if (timerBlack <= 0) {
                    gameOver = true;
                    stopTimer();
                    showMessage('Temps √©coul√©! Les Blancs gagnent! ‚è±Ô∏è', 'checkmate');
                    return;
                }
                if (timerBlack <= 30) {
                    document.getElementById('timer-black').classList.add('warning');
                }
            }
            
            updateTimerDisplay();
        }
    }, 1000);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function updateTimerDisplay() {
    document.getElementById('timer-white').textContent = formatTime(timerWhite);
    document.getElementById('timer-black').textContent = formatTime(timerBlack);
    
    if (timerWhite > 30) {
        document.getElementById('timer-white').classList.remove('warning');
    }
    if (timerBlack > 30) {
        document.getElementById('timer-black').classList.remove('warning');
    }
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function updatePlayerActive() {
    const whitePlayer = document.getElementById('player-white');
    const blackPlayer = document.getElementById('player-black');
    
    if (currentPlayer === 'white') {
        whitePlayer.classList.add('active');
        blackPlayer.classList.remove('active');
    } else {
        blackPlayer.classList.add('active');
        whitePlayer.classList.remove('active');
    }
}

function showMessage(text, className) {
    const messageEl = document.getElementById('message');
    messageEl.textContent = text;
    messageEl.className = `${className}`;
}

function togglePause() {
    isPaused = !isPaused;
    const pauseBtn = document.getElementById('pause');
    pauseBtn.innerHTML = isPaused ? '‚ñ∂ Reprendre' : '‚è∏ Pause';
    
    if (isPaused) {
        document.getElementById('status').textContent = '‚è∏ Jeu en pause';
    } else {
        document.getElementById('status').textContent = '';
    }
}

document.getElementById('reset').addEventListener('click', initGame);
document.getElementById('pause').addEventListener('click', togglePause);

initGame();
    </script>
</body>
</html>
