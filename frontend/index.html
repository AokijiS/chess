<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess.com - Play Chess Online</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
    color: #ffffff;
}

.main-container {
    display: flex;
    gap: 20px;
    max-width: 1400px;
    width: 100%;
}

.sidebar {
    width: 340px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 24px;
    height: fit-content;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.game-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 720px;
}

.player-panel {
    width: 100%;
    max-width: 720px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 16px 20px;
    border-radius: 12px;
    margin-bottom: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.3s ease;
}

.player-panel.active {
    background: rgba(129, 182, 76, 0.15);
    border: 2px solid #81b64c;
    box-shadow: 0 0 20px rgba(129, 182, 76, 0.3);
}

.player-left {
    display: flex;
    align-items: center;
    gap: 14px;
}

.avatar {
    width: 48px;
    height: 48px;
    border-radius: 4px;
    background: linear-gradient(135deg, #81b64c 0%, #6fa03d 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.player-details {
    display: flex;
    flex-direction: column;
}

.player-name {
    font-size: 17px;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 2px;
}

.player-rating {
    font-size: 13px;
    color: #959492;
}

.timer {
    font-size: 32px;
    font-weight: 700;
    font-family: 'Courier New', monospace;
    background: #1a1917;
    padding: 10px 20px;
    border-radius: 6px;
    min-width: 110px;
    text-align: center;
    color: #ffffff;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
}

.timer.warning {
    background: #cc3333;
    animation: timerPulse 1s infinite;
}

@keyframes timerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

#chessboard-wrapper {
    position: relative;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    border-radius: 8px;
    overflow: hidden;
}

#chessboard {
    display: grid;
    grid-template-columns: repeat(8, 90px);
    grid-template-rows: repeat(8, 90px);
    border: 4px solid rgba(255, 255, 255, 0.1);
    background: #312e2b;
}

.square {
    width: 90px;
    height: 90px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    position: relative;
    user-select: none;
    transition: all 0.15s ease;
}

.square svg {
    width: 70px;
    height: 70px;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    transition: transform 0.15s ease;
}

.square:hover svg {
    transform: scale(1.05);
}

.light {
    background-color: #f0d9b5;
}

.dark {
    background-color: #b58863;
}

.square:hover {
    filter: brightness(0.95);
}

.selected {
    background-color: rgba(186, 202, 68, 0.8) !important;
    box-shadow: inset 0 0 0 3px rgba(186, 202, 68, 1);
}

.last-move {
    background-color: rgba(205, 210, 106, 0.6) !important;
}

.valid-move::after {
    content: '';
    position: absolute;
    width: 30px;
    height: 30px;
    background: rgba(20, 85, 30, 0.5);
    border-radius: 50%;
    pointer-events: none;
}

.valid-move.capture::after {
    width: 84px;
    height: 84px;
    background: transparent;
    border: 6px solid rgba(20, 85, 30, 0.5);
    border-radius: 50%;
}

.in-check {
    background: radial-gradient(ellipse at center, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.7) 40%, transparent 70%) !important;
    animation: checkPulse 1s ease-in-out infinite;
    box-shadow: 0 0 30px rgba(231, 76, 60, 0.8), inset 0 0 30px rgba(231, 76, 60, 0.5);
}

.checkmate-highlight {
    background: radial-gradient(ellipse at center, rgba(155, 89, 182, 0.9) 0%, rgba(142, 68, 173, 0.7) 40%, transparent 70%) !important;
    animation: checkmateFlash 1.5s ease-in-out infinite;
    box-shadow: 0 0 40px rgba(155, 89, 182, 1), inset 0 0 40px rgba(155, 89, 182, 0.6);
}

@keyframes checkPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@keyframes checkmateFlash {
    0%, 100% { 
        opacity: 1;
        box-shadow: 0 0 40px rgba(155, 89, 182, 1), inset 0 0 40px rgba(155, 89, 182, 0.6);
    }
    50% { 
        opacity: 0.6;
        box-shadow: 0 0 60px rgba(155, 89, 182, 1), inset 0 0 60px rgba(155, 89, 182, 0.8);
    }
}

.board-controls {
    width: 100%;
    max-width: 720px;
    display: flex;
    gap: 12px;
    margin-top: 16px;
    justify-content: center;
}

.btn {
    background: linear-gradient(135deg, #81b64c 0%, #6fa03d 100%);
    color: #ffffff;
    border: none;
    padding: 14px 28px;
    border-radius: 8px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'Inter', sans-serif;
    box-shadow: 0 4px 12px rgba(129, 182, 76, 0.3);
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(129, 182, 76, 0.4);
}

.btn:active {
    transform: translateY(0);
}

.btn-secondary {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.btn-secondary:hover {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.1) 100%);
}

.sidebar-section {
    background: #1a1917;
    border-radius: 8px;
    padding: 18px;
    margin-bottom: 16px;
}

.sidebar-title {
    font-size: 16px;
    font-weight: 700;
    color: #ffffff;
    margin-bottom: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.connection-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px;
    background: #262421;
    border-radius: 6px;
    margin-bottom: 16px;
}

.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #cc3333;
    box-shadow: 0 0 8px rgba(204,51,51,0.5);
}

.status-dot.connected {
    background: #81b64c;
    box-shadow: 0 0 8px rgba(129,182,76,0.5);
}

.status-text {
    font-size: 14px;
    font-weight: 500;
}

.mode-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.mode-btn {
    background: #3d3c38;
    color: #ffffff;
    border: 2px solid transparent;
    padding: 16px;
    border-radius: 6px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 10px;
}

.mode-btn:hover {
    background: #4f4e49;
    border-color: #81b64c;
}

.mode-btn.active {
    background: #81b64c;
    border-color: #96c961;
}

.game-code-box {
    background: #262421;
    padding: 16px;
    border-radius: 6px;
    margin-top: 12px;
}

.game-code-box input {
    background: #1a1917;
    border: 2px solid #3d3c38;
    color: #ffffff;
    padding: 12px;
    border-radius: 6px;
    width: 100%;
    font-size: 18px;
    font-family: 'Courier New', monospace;
    text-align: center;
    font-weight: 700;
    letter-spacing: 2px;
}

.game-code-box input:focus {
    outline: none;
    border-color: #81b64c;
}

.status-banner {
    background: #3d3c38;
    padding: 16px;
    border-radius: 6px;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    min-height: 54px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.status-banner.success {
    background: #81b64c;
    color: #ffffff;
}

.status-banner.error {
    background: #cc3333;
    color: #ffffff;
}

.status-banner.info {
    background: #4a9fd8;
    color: #ffffff;
}

@media (max-width: 1200px) {
    .main-container {
        flex-direction: column;
        align-items: center;
    }
    
    .sidebar {
        width: 100%;
        max-width: 720px;
    }
}

@media (max-width: 768px) {
    #chessboard {
        grid-template-columns: repeat(8, 50px);
        grid-template-rows: repeat(8, 50px);
    }
    
    .square {
        width: 50px;
        height: 50px;
    }
    
    .square svg {
        width: 40px;
        height: 40px;
    }
    
    .valid-move.capture::after {
        width: 45px;
        height: 45px;
        border-width: 3px;
    }
}
    </style>
</head>
<body>
    <div class="main-container">
        <aside class="sidebar">
            <div class="connection-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span class="status-text" id="status-text">D√©connect√©</span>
            </div>
            
            <div class="sidebar-section">
                <h3 class="sidebar-title">Mode de jeu</h3>
                <div class="mode-buttons">
                    <button class="mode-btn active" onclick="setMode('local')">
                        <span>üè†</span> Jouer localement
                    </button>
                    <button class="mode-btn" onclick="setMode('create')">
                        <span>üåê</span> Cr√©er une partie en ligne
                    </button>
                    <button class="mode-btn" onclick="setMode('join')">
                        <span>üîó</span> Rejoindre une partie
                    </button>
                </div>
                
                <div class="game-code-box" id="code-display" style="display:none;">
                    <input type="text" id="game-code-input" readonly>
                    <button class="btn" onclick="copyCode()" style="width:100%; margin-top:10px;">
                        üìã Copier le code
                    </button>
                </div>
                
                <div class="game-code-box" id="code-join" style="display:none;">
                    <input type="text" id="join-code-input" placeholder="CODE123">
                    <button class="btn" onclick="joinGame()" style="width:100%; margin-top:10px;">
                        ‚úì Rejoindre la partie
                    </button>
                </div>
            </div>
            
            <div class="status-banner" id="status-banner">
                S√©lectionnez un mode de jeu pour commencer
            </div>
        </aside>
        
        <main class="game-area">
            <div class="player-panel" id="player-black">
                <div class="player-left">
                    <div class="avatar">‚ôö</div>
                    <div class="player-details">
                        <div class="player-name" id="black-name">Joueur Noir</div>
                        <div class="player-rating">En attente...</div>
                    </div>
                </div>
                <div class="timer" id="timer-black">10:00</div>
            </div>
            
            <div id="chessboard-wrapper">
                <div id="chessboard"></div>
            </div>
            
            <div class="player-panel active" id="player-white">
                <div class="player-left">
                    <div class="avatar">‚ôî</div>
                    <div class="player-details">
                        <div class="player-name" id="white-name">Joueur Blanc</div>
                        <div class="player-rating">En attente...</div>
                    </div>
                </div>
                <div class="timer" id="timer-white">10:00</div>
            </div>
            
            <div class="board-controls">
                <button class="btn" onclick="resetGame()">üîÑ Nouvelle Partie</button>
                <button class="btn btn-secondary" onclick="togglePause()">‚è∏ Pause</button>
            </div>
        </main>
    </div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
const BACKEND_URL = 'https://chess-m17n.onrender.com';

const pieces = {
    white: { king: '‚ôî', queen: '‚ôï', rook: '‚ôñ', bishop: '‚ôó', knight: '‚ôò', pawn: '‚ôô' },
    black: { king: '‚ôö', queen: '‚ôõ', rook: '‚ôú', bishop: '‚ôù', knight: '‚ôû', pawn: '‚ôü' }
};

const pieceSVG = {
    '‚ôî': '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#fff" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z" fill="#fff"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>',
    '‚ôï': '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zm16.5-4.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-14V25L7 14l2 12z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" stroke-linecap="butt"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none"/></g></svg>',
    '‚ôñ': '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zm3-3v-4h21v4H12zm-1-22V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
    '‚ôó': '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zm6-4c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
    '‚ôò': '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#fff"/><path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#fff"/><path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#000"/></g></svg>',
    '‚ôô': '<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round"/></svg>',
    '‚ôö': '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#000" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z" fill="#000"/><path d="M20 8h5" stroke-linejoin="miter"/><path d="M32 29.5s8.5-4 6.03-9.65C34.15 14 25 18 22.5 24.5l.01 2.1-.01-2.1C20 18 9.906 14 6.997 19.85c-2.497 5.65 4.853 9 4.853 9M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0" stroke="#fff"/></g></svg>',
    '‚ôõ': '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g stroke="none"><circle cx="6" cy="12" r="2.75"/><circle cx="14" cy="9" r="2.75"/><circle cx="22.5" cy="8" r="2.75"/><circle cx="31" cy="9" r="2.75"/><circle cx="39" cy="12" r="2.75"/></g><path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" stroke-linecap="butt"/><path d="M11 38.5a35 35 1 0 0 23 0" fill="none" stroke-linecap="butt"/><path d="M11 29a35 35 1 0 1 23 0m-21.5 2.5h20m-21 3a35 35 1 0 0 22 0m-23 3a35 35 1 0 0 24 0" fill="none" stroke="#fff"/></g></svg>',
    '‚ôú': '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zm3.5-7l1.5-2.5h17l1.5 2.5h-20zm-.5 4v-4h21v4H12z" stroke-linecap="butt"/><path d="M14 29.5v-13h17v13H14z" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z" stroke-linecap="butt"/><path d="M12 35.5h21m-20-4h19m-18-2h17m-17-13h17M11 14h23" fill="none" stroke="#fff" stroke-width="1" stroke-linejoin="miter"/></g></svg>',
    '‚ôù': '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000" stroke-linecap="butt"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zm6-4c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke="#fff" stroke-linejoin="miter"/></g></svg>',
    '‚ôû': '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#000"/><path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#000"/><path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#fff" stroke="#fff"/><path d="M24.55 10.4l-.45 1.45.5.15c3.15 1 5.65 2.49 7.9 6.75S35.75 29.06 35.25 39l-.05.5h2.25l.05-.5c.5-10.06-.88-16.85-3.25-21.34-2.37-4.49-5.79-6.64-9.19-7.16l-.51-.1z" fill="#fff" stroke="none"/></g></svg>',
    '‚ôü': '<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round"/></svg>'
};

let board = [];
let selectedSquare = null;
let currentPlayer = 'white';
let gameOver = false;
let isPaused = false;
let timerWhite = 600;
let timerBlack = 600;
let timerInterval = null;
let lastMove = null;
let gameMode = 'local';
let socket = null;
let gameCode = null;
let playerColor = null;
let isMyTurn = false;

const initialBoard = [
    ['‚ôú','‚ôû','‚ôù','‚ôõ','‚ôö','‚ôù','‚ôû','‚ôú'],
    ['‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô'],
    ['‚ôñ','‚ôò','‚ôó','‚ôï','‚ôî','‚ôó','‚ôò','‚ôñ']
];

function setMode(mode) {
    gameMode = mode;
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    document.getElementById('code-display').style.display = 'none';
    document.getElementById('code-join').style.display = 'none';
    
    if (mode === 'local') {
        showStatus('Mode local activ√©. Cliquez sur "Nouvelle Partie".', 'info');
        if (socket) socket.disconnect();
        playerColor = null;
        isMyTurn = true;
    } else if (mode === 'create') {
        connectWebSocket();
        createOnlineGame();
    } else if (mode === 'join') {
        connectWebSocket();
        document.getElementById('code-join').style.display = 'block';
        showStatus('Entrez le code de partie pour rejoindre.', 'info');
    }
}

function connectWebSocket() {
    if (socket && socket.connected) return;
    
    socket = io(BACKEND_URL, {
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        reconnectionAttempts: 10
    });
    
    socket.on('connect', () => {
        document.getElementById('status-dot').classList.add('connected');
        document.getElementById('status-text').textContent = 'Connect√©';
        showStatus('Connect√© au serveur', 'success');
    });
    
    socket.on('disconnect', () => {
        document.getElementById('status-dot').classList.remove('connected');
        document.getElementById('status-text').textContent = 'D√©connect√©';
        showStatus('D√©connect√© du serveur', 'error');
    });
    
    socket.on('gameCreated', (data) => {
        gameCode = data.gameCode;
        playerColor = 'white';
        isMyTurn = true;
        document.getElementById('game-code-input').value = gameCode;
        document.getElementById('code-display').style.display = 'block';
        showStatus(`Partie cr√©√©e! Code: ${gameCode}. En attente d'adversaire...`, 'success');
        document.getElementById('white-name').textContent = 'Vous (Blanc)';
        document.getElementById('black-name').textContent = 'En attente...';
    });
    
    socket.on('opponentJoined', (data) => {
        showStatus('Adversaire connect√©! La partie commence.', 'success');
        document.getElementById('black-name').textContent = 'Adversaire (Noir)';
        resetGame();
    });
    
    socket.on('gameJoined', (data) => {
        gameCode = data.gameCode;
        playerColor = 'black';
        isMyTurn = false;
        showStatus('Partie rejointe! La partie commence.', 'success');
        document.getElementById('black-name').textContent = 'Vous (Noir)';
        document.getElementById('white-name').textContent = 'Adversaire (Blanc)';
        resetGame();
    });
    
    socket.on('move', (data) => {
        board = data.board;
        currentPlayer = data.currentPlayer;
        timerWhite = data.timerWhite;
        timerBlack = data.timerBlack;
        lastMove = data.lastMove;
        isMyTurn = (currentPlayer === playerColor);
        
        renderBoard();
        updatePlayerActive();
        updateTimerDisplay();
        checkGameEnd();
        
        if (isMyTurn) {
            showStatus('√Ä votre tour!', 'info');
        } else {
            showStatus('Tour de l\'adversaire...', 'info');
        }
    });
    
    socket.on('gameEnd', (data) => {
        gameOver = true;
        stopTimer();
        showStatus(data.message, 'info');
    });
    
    socket.on('error', (data) => {
        showStatus(data.message, 'error');
    });
}

function createOnlineGame() {
    if (socket && socket.connected) {
        socket.emit('createGame');
    } else {
        showStatus('Connexion au serveur...', 'info');
        setTimeout(createOnlineGame, 1000);
    }
}

function joinGame() {
    const code = document.getElementById('join-code-input').value.trim().toUpperCase();
    if (!code) {
        showStatus('Veuillez entrer un code de partie', 'error');
        return;
    }
    
    if (socket && socket.connected) {
        socket.emit('joinGame', { gameCode: code });
    } else {
        showStatus('Connexion au serveur...', 'info');
        setTimeout(() => joinGame(), 1000);
    }
}

function copyCode() {
    const codeInput = document.getElementById('game-code-input');
    codeInput.select();
    document.execCommand('copy');
    showStatus('Code copi√© dans le presse-papier!', 'success');
}

function showStatus(message, type) {
    const banner = document.getElementById('status-banner');
    banner.textContent = message;
    banner.className = `status-banner ${type}`;
}

function resetGame() {
    board = initialBoard.map(row => [...row]);
    currentPlayer = 'white';
    gameOver = false;
    isPaused = false;
    selectedSquare = null;
    timerWhite = 600;
    timerBlack = 600;
    lastMove = null;
    
    if (gameMode === 'local') {
        isMyTurn = true;
        playerColor = null;
    } else {
        isMyTurn = (playerColor === 'white');
    }
    
    updateTimerDisplay();
    updatePlayerActive();
    renderBoard();
    startTimer();
    
    if (gameMode === 'local') {
        showStatus('Partie locale en cours', 'info');
    } else if (isMyTurn) {
        showStatus('√Ä votre tour!', 'info');
    } else {
        showStatus('Tour de l\'adversaire...', 'info');
    }
}

function renderBoard() {
    const chessboard = document.getElementById('chessboard');
    chessboard.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
            square.dataset.row = row;
            square.dataset.col = col;
            
            const piece = board[row][col];
            if (piece && pieceSVG[piece]) {
                square.innerHTML = pieceSVG[piece];
            }
            
            square.addEventListener('click', () => handleSquareClick(row, col));
            
            if (lastMove && 
                ((lastMove.from.row === row && lastMove.from.col === col) || 
                 (lastMove.to.row === row && lastMove.to.col === col))) {
                square.classList.add('last-move');
            }
            
            chessboard.appendChild(square);
        }
    }
    
    highlightKingInCheck();
}

function handleSquareClick(row, col) {
    if (gameOver || isPaused) return;
    
    if (gameMode !== 'local') {
        if (!isMyTurn) {
            showStatus('Attendez votre tour!', 'error');
            return;
        }
        if (currentPlayer !== playerColor) return;
    }
    
    const clickedPiece = board[row][col];
    
    if (selectedSquare) {
        const validMoves = getValidMoves(selectedSquare.row, selectedSquare.col);
        const isValidMove = validMoves.some(move => move.row === row && move.col === col);
        
        if (isValidMove) {
            const move = {
                from: { row: selectedSquare.row, col: selectedSquare.col },
                to: { row, col }
            };
            
            movePiece(selectedSquare.row, selectedSquare.col, row, col);
            lastMove = move;
            selectedSquare = null;
            clearHighlights();
            evaluateCheckState();

            
            if (gameMode !== 'local' && socket && socket.connected) {
                isMyTurn = false;
                socket.emit('move', {
                    gameCode,
                    board,
                    currentPlayer: currentPlayer === 'white' ? 'black' : 'white',
                    timerWhite,
                    timerBlack,
                    lastMove
                });
                showStatus('Coup envoy√©. Tour de l\'adversaire...', 'info');
            }
            
            checkGameEnd();
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updatePlayerActive();
        } else {
            selectedSquare = null;
            clearHighlights();
            
            if (clickedPiece && getPieceColor(clickedPiece) === currentPlayer) {
                selectSquare(row, col);
            }
        }
    } else {
        if (clickedPiece && getPieceColor(clickedPiece) === currentPlayer) {
            selectSquare(row, col);
        }
    }
}

function checkGameEnd() {
    const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
    const isInCheck = isKingInCheck(opponentColor);
    
    if (checkForCheckmate(opponentColor)) {
        gameOver = true;
        stopTimer();
        const winner = currentPlayer === 'white' ? 'Blancs' : 'Noirs';
        showStatus(`√âchec et Mat! Les ${winner} gagnent! üëë`, 'success');
        return;
    }
    
    if (checkForStalemate(opponentColor)) {
        gameOver = true;
        stopTimer();
        showStatus('Pat! Match nul!', 'info');
        return;
    }

}

function selectSquare(row, col) {
    selectedSquare = { row, col };
    highlightSquare(row, col);
    highlightValidMoves(row, col);
}

function highlightSquare(row, col) {
    const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    square.classList.add('selected');
}

function highlightValidMoves(row, col) {
    const validMoves = getValidMoves(row, col);
    validMoves.forEach(move => {
        const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
        square.classList.add('valid-move');
        if (board[move.row][move.col]) {
            square.classList.add('capture');
        }
    });
}

function clearHighlights() {
    document.querySelectorAll('.square').forEach(square => {
        square.classList.remove('selected', 'valid-move', 'capture');
    });
}

function highlightKingInCheck() {
    document.querySelectorAll('.in-check, .checkmate-highlight').forEach(sq => {
        sq.classList.remove('in-check', 'checkmate-highlight');
    });
    
    const kingPos = findKing(currentPlayer);
    if (kingPos && isKingInCheck(currentPlayer)) {
        const square = document.querySelector(`[data-row="${kingPos.row}"][data-col="${kingPos.col}"]`);
        
        if (checkForCheckmate(currentPlayer)) {
            square.classList.add('checkmate-highlight');
        } else {
            square.classList.add('in-check');
        }
    }
}

function movePiece(fromRow, fromCol, toRow, toCol) {
    board[toRow][toCol] = board[fromRow][fromCol];
    board[fromRow][fromCol] = '';
    renderBoard();
}

function getPieceColor(piece) {
    if (Object.values(pieces.white).includes(piece)) return 'white';
    if (Object.values(pieces.black).includes(piece)) return 'black';
    return null;
}

function getPieceType(piece) {
    for (let color in pieces) {
        for (let type in pieces[color]) {
            if (pieces[color][type] === piece) return type;
        }
    }
    return null;
}

function getValidMoves(row, col) {
    const piece = board[row][col];
    const pieceType = getPieceType(piece);
    const pieceColor = getPieceColor(piece);
    if (!pieceType) return [];
    
    let moves = [];
    switch(pieceType) {
        case 'pawn': moves = getPawnMoves(row, col, pieceColor); break;
        case 'rook': moves = getRookMoves(row, col, pieceColor); break;
        case 'knight': moves = getKnightMoves(row, col, pieceColor); break;
        case 'bishop': moves = getBishopMoves(row, col, pieceColor); break;
        case 'queen': moves = getQueenMoves(row, col, pieceColor); break;
        case 'king': moves = getKingMoves(row, col, pieceColor); break;
    }
    return moves.filter(move => !wouldBeInCheck(row, col, move.row, move.col, pieceColor));
}

function getPawnMoves(row, col, color) {
    const moves = [], direction = color === 'white' ? -1 : 1, startRow = color === 'white' ? 6 : 1;
    if (isValidSquare(row + direction, col) && !board[row + direction][col]) {
        moves.push({ row: row + direction, col });
        if (row === startRow && !board[row + 2 * direction][col]) {
            moves.push({ row: row + 2 * direction, col });
        }
    }
    [[row + direction, col - 1], [row + direction, col + 1]].forEach(([r, c]) => {
        if (isValidSquare(r, c) && board[r][c] && getPieceColor(board[r][c]) !== color) {
            moves.push({ row: r, col: c });
        }
    });
    return moves;
}

function getRookMoves(row, col, color) {
    return getSlidingMoves(row, col, color, [[0,1],[0,-1],[1,0],[-1,0]]);
}

function getBishopMoves(row, col, color) {
    return getSlidingMoves(row, col, color, [[1,1],[1,-1],[-1,1],[-1,-1]]);
}

function getQueenMoves(row, col, color) {
    return getSlidingMoves(row, col, color, [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]);
}

function getSlidingMoves(row, col, color, directions) {
    const moves = [];
    directions.forEach(([dRow, dCol]) => {
        let r = row + dRow, c = col + dCol;
        while (isValidSquare(r, c)) {
            if (!board[r][c]) {
                moves.push({ row: r, col: c });
            } else {
                if (getPieceColor(board[r][c]) !== color) moves.push({ row: r, col: c });
                break;
            }
            r += dRow; c += dCol;
        }
    });
    return moves;
}

function getKnightMoves(row, col, color) {
    const moves = [];
    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dRow, dCol]) => {
        const r = row + dRow, c = col + dCol;
        if (isValidSquare(r, c) && (!board[r][c] || getPieceColor(board[r][c]) !== color)) {
            moves.push({ row: r, col: c });
        }
    });
    return moves;
}

function getKingMoves(row, col, color) {
    const moves = [];
    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dRow, dCol]) => {
        const r = row + dRow, c = col + dCol;
        if (isValidSquare(r, c) && (!board[r][c] || getPieceColor(board[r][c]) !== color)) {
            moves.push({ row: r, col: c });
        }
    });
    return moves;
}

function isValidSquare(row, col) {
    return row >= 0 && row < 8 && col >= 0 && col < 8;
}

function findKing(color) {
    const kingPiece = pieces[color].king;
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (board[row][col] === kingPiece) return { row, col };
        }
    }
    return null;
}

function isKingInCheck(color) {
    const kingPos = findKing(color);
    if (!kingPos) return false;
    const opponentColor = color === 'white' ? 'black' : 'white';
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === opponentColor) {
                const moves = getPieceMoves(row, col, opponentColor);
                if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) return true;
            }
        }
    }
    return false;
}

function getPieceMoves(row, col, color) {
    const pieceType = getPieceType(board[row][col]);
    switch(pieceType) {
        case 'pawn': return getPawnMoves(row, col, color);
        case 'rook': return getRookMoves(row, col, color);
        case 'knight': return getKnightMoves(row, col, color);
        case 'bishop': return getBishopMoves(row, col, color);
        case 'queen': return getQueenMoves(row, col, color);
        case 'king': return getKingMoves(row, col, color);
        default: return [];
    }
}

function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
    const originalPiece = board[toRow][toCol], movingPiece = board[fromRow][fromCol];
    board[toRow][toCol] = movingPiece;
    board[fromRow][fromCol] = '';
    const inCheck = isKingInCheck(color);
    board[fromRow][fromCol] = movingPiece;
    board[toRow][toCol] = originalPiece;
    return inCheck;
}

function checkForCheckmate(color) {
    if (!isKingInCheck(color)) return false;
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === color && getValidMoves(row, col).length > 0) return false;
        }
    }
    return true;
}

function checkForStalemate(color) {
    if (isKingInCheck(color)) return false;
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === color && getValidMoves(row, col).length > 0) return false;
        }
    }
    return true;
}

function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        if (!gameOver && !isPaused) {
            if (currentPlayer === 'white') {
                timerWhite--;
                if (timerWhite <= 0) {
                    gameOver = true; stopTimer();
                    showStatus('Temps √©coul√©! Les Noirs gagnent! ‚è±Ô∏è', 'success');
                    return;
                }
                if (timerWhite <= 30) document.getElementById('timer-white').classList.add('warning');
            } else {
                timerBlack--;
                if (timerBlack <= 0) {
                    gameOver = true; stopTimer();
                    showStatus('Temps √©coul√©! Les Blancs gagnent! ‚è±Ô∏è', 'success');
                    return;
                }
                if (timerBlack <= 30) document.getElementById('timer-black').classList.add('warning');
            }
            updateTimerDisplay();
        }
    }, 1000);
}

function stopTimer() {
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function updateTimerDisplay() {
    document.getElementById('timer-white').textContent = formatTime(timerWhite);
    document.getElementById('timer-black').textContent = formatTime(timerBlack);
    if (timerWhite > 30) document.getElementById('timer-white').classList.remove('warning');
    if (timerBlack > 30) document.getElementById('timer-black').classList.remove('warning');
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60), secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function updatePlayerActive() {
    const whitePlayer = document.getElementById('player-white');
    const blackPlayer = document.getElementById('player-black');
    if (currentPlayer === 'white') {
        whitePlayer.classList.add('active');
        blackPlayer.classList.remove('active');
    } else {
        blackPlayer.classList.add('active');
        whitePlayer.classList.remove('active');
    }
}

function togglePause() {
    isPaused = !isPaused;
    event.target.innerHTML = isPaused ? '‚ñ∂ Reprendre' : '‚è∏ Pause';
    showStatus(isPaused ? '‚è∏ Jeu en pause' : 'Partie en cours', 'info');
}

function evaluateCheckState() {
    const opponentColor = currentPlayer === 'white' ? 'black' : 'white';

    // √âCHEC ET MAT
    if (checkForCheckmate(opponentColor)) {
        gameOver = true;
        stopTimer();

        highlightKingInCheck();
        showStatus(
            `‚ôö √âchec et mat ! Les ${currentPlayer === 'white' ? 'Blancs' : 'Noirs'} gagnent.`,
            'success'
        );
        return;
    }

    // √âCHEC SIMPLE
    if (isKingInCheck(opponentColor)) {
        highlightKingInCheck();
        showStatus('‚ö† √âchec !', 'error');
    }
}


resetGame();
    </script>
</body>
</html>